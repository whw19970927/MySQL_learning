## 索引的定义

**索引**是存储引擎用于快速查找记录的一种数据结构。

Mysql官方的定义：索引是帮助Mysql高效获取数据的数据结构

### 七大查找算法

* 顺序查找

* 二分查找

* 插值查找

* 斐波那契查找

* 树表查找

* 分块查找

* 哈希查找

  https://www.cnblogs.com/yw09041432/p/5908444.html

### 索引数据结构

![image](https://github.com/whw19970927/Mysql-learning/blob/master/Image/image-20200717192100313.png)

#### 哈希表

![image](https://github.com/whw19970927/Mysql-learning/blob/master/Image/image-20200717192207981.png)

Hash冲突解决方法：

* 开放地址法
* 拉链法
* 再hash法（但如果还是会造成hash冲突就要再次散列，增加计算时间）

因为散列表的性质，Hash索引指向的数据是无序的，这就会导致使用Hash索引的话，无法进行范围查询。所以Hash表结构适用于只有等值查询的查询。并且Hash索引无论如何不能避免回表查询。

哈希索引缺点

* 哈希索引只包含哈希值和行指针，所以不能用索引中的值来避免读取行
* 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序和范围查询
* 哈希索引也不支持部分索引列查询，因为哈希索引始终是使用索引列的全部数据进行哈希计算的。
* 哈希索引只支持等值比较查询，如=，IN()，<=>操作
* 如果哈希冲突较多，一些索引的维护操作的代价也会更高



#### 有序数组

)
![image](https://github.com/whw19970927/Mysql-learning/blob/master/Image/image-20200717193043275.png)

得益于是有序数组，所以等值查询和范围查询场景中的性能就都非常优秀。

但由于数组的数据结构特性，修改，删除，插入的成本都非常高。因为数组的操作需要涉嫌到当前位置后面的所有数组元素的位移。另外，数组使用的是连续的内存空间，可以利用空间局部性原理借助cpu缓存预读，所以访问效率较高。



使用场景：

只适用于静态存储索引，在InnoDB中没有，只有Myisam中有



**Q：为什么Mysql使用B+树而不是B或者红黑树？**

首先复习各种树的概念

![image](https://github.com/whw19970927/Mysql-learning/blob/master/Image/image-20200717194541407.png)



![image](https://github.com/whw19970927/Mysql-learning/blob/master/Image/image-20200717195206478.png)

很容易就能得到结论：

* B树的所有节点都存放了索引和数据，而B+树则在非叶子节点只存放索引，所以变相地得增加了磁盘IO的次数，因为磁盘每次读出的数据量大小是一定的，单个节点数据量变大，读出的节点数量就少，磁盘IO的次数就增加

* B+树的叶子节点上存放了排序后的全量数据，所以查找起来速度非常快，并且一次遍历就可以获得所有数据，而B树则不支持这样的操作

* 红黑树相比于B+树，他的树高会高很多，因为红黑树是弱自平衡的二叉搜索树，所以更高的树高也就对应了更多的IO次数和更低的效率。为什么会出现这样的情况，我们知道要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数往往由树的高度所决定，所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度。而一般3层的B+树就可以容纳千万级别的数据。





**Q：主键索引和普通索引有什么区别？**

A：主键查询方式，只需要查询ID这一棵B+树即可。

​		普通索引查询方式则需要先搜索索引树，得到对应的ID值，再去主键索引进行回表查询（覆盖索引可以避免回表查询）





## 索引分类

* 单列索引
* 组合索引
* 全文索引
* 空间索引

* 聚簇索引
* 非聚簇索引



## 索引的维护

![image](https://github.com/whw19970927/Mysql-learning/blob/master/Image/image-20200717210049433.png)



我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以 ***不得不*** 依次遍历所有的数据页。所以如果我们想快速的定位到需要查找的记录在哪些数据页中该咋办？还记得我们为根据主键值快速定位一条记录在页中的位置而设立的页目录么？我们也可以想办法为快速定位记录所在的数据页而建立一个别的目录，建这个目录必须完成下边这些事儿：

- 下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。

  为了故事的顺利发展，我们这里需要做一个假设：假设我们的每个数据页最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录）。有了这个假设之后我们向`index_demo`表插入3条记录：

  ```
  mysql> INSERT INTO index_demo VALUES(1, 4, 'u'), (3, 9, 'd'), (5, 3, 'y');
  Query OK, 3 rows affected (0.01 sec)
  Records: 3  Duplicates: 0  Warnings: 0
  ```

  那么这些记录已经按照主键值的大小串联成一个单向链表了，如图所示：

  

 ![image](https://github.com/whw19970927/Mysql-learning/blob/master/Image/image-20200717221327132.png)

  从图中可以看出来，`index_demo`表中的3条记录都被插入到了编号为`10`的数据页中了。此时我们再来插入一条记录：

  ```
  mysql> INSERT INTO index_demo VALUES(4, 4, 'a');
  Query OK, 1 row affected (0.00 sec)
  ```

  因为`页10`最多只能放3条记录，所以我们<span style="color:red">不得不</span>再分配一个新页：

 ![image](https://github.com/whw19970927/Mysql-learning/blob/master/Image/image-20200717221338823.png)

  咦？怎么分配的页号是`28`呀，不应该是`11`么？再次强调一遍，<span style="color:red">新分配的数据页编号可能并不是连续的，也就是说我们使用的这些页在存储空间里可能并不挨着</span>。它们只是通过维护着上一个页和下一个页的编号而建立了链表关系。另外，`页10`中用户记录最大的主键值是`5`，而`页28`中有一条记录的主键值是`4`，因为`5 > 4`，所以这就不符合<span style="color:red">下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</span>的要求，所以在插入主键值为`4`的记录的时候需要伴随着一次记录移动，也就是把主键值为`5`的记录移动到`页28`中，然后再把主键值为`4`的记录插入到`页10`中，这个过程的示意图如下：

  ![image](https://github.com/whw19970927/Mysql-learning/blob/master/Image/image-20200717221358355.png)

  这个过程表明了在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立：<span style="color:red">下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</span>。这个过程我们也可以称为**页分裂**。

  **我们可以理解为页内二分，页与页之间通过链表相链**

## INNODB和MYISAM区别

 ![image](https://github.com/whw19970927/Mysql-learning/blob/master/Image/image-20200717211811071.png)

 ![image](https://github.com/whw19970927/Mysql-learning/blob/master/Image/image-20200717223158884.png)

图一是非聚簇索引，图二是聚簇索引。Myisam在磁盘中存储的索引文件分为.MYI和.MYD两种，也就是Index和Data，分别是索引和数据，也就是分开的，Innodb中的是放在一个ibd文件里的（聚簇索引）。





* 叶节点的data域存放的是数据记录的地址

* 主索引和辅助索引在结构上没有任何区别，只是主索引要求key是唯一的
* InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形



